import pandas as pd
import numpy as np
import os
import ast
import scipy
import warnings
from rdkit import Chem, DataStructs, RDConfig
from rdkit.Chem import ChemicalFeatures
from rdkit.Chem.Scaffolds import MurckoScaffold
from Bio import PDB
from Bio import Data
from Bio import Align
from sbdd_bench.sbdd_analysis.eval_metrics import recreatedPLIP
from sbdd_bench.sbdd_analysis.constants import (
    BLIND_SET_POCKET_IDS,
    BLIND_SET_PDBS_TO_POCKET_IDS,
    TASK2_FUNC_TO_PDBS,
    TASK3_FUNC_TO_PDBS,
    ALL_PDBS,
    DPOCKET_TYPES,
)
from prot_lig_combine import combine


def mol_com(mol):
    """
    Gets molecule center of mass from RDKit Mol object

    Parameters
    ----------
        mol: RDKit Mol object

    Returns
    -------
        mol_com: list of molecule's center of mass

    """

    if mol is not None:
        return Chem.rdMolTransforms.ComputeCentroid(mol.GetConformer())
    
    return None


def prot_com(residue_list, residue_id):
    """
    Gets COM of PDB residue

    Parameters
    ----------
        residue_obj: BioPython list of residue objects
            Residues to parse through
        residue_id: int
            ID of residue to extract

    Returns
    -------
        com: Center of mass of residue

    """

    com = [
        i.center_of_mass() for i in residue_list if i.get_id()[1] == int(residue_id)
    ][0]
    return com


def sim_2d(gen_fp, true_fp):
    """
    Calculates 2D similarities using RDKit fingerprints of generated and true compounds

    Parameters
    ----------
        gen_fp: RDKit fingerprint object
            Fingerprint of generated molecule
        true_fp: RDKit Mol object
            Fingerprint of molecule from crystal data or hits

    Returns
    -------
        sim_2d: float of 2D Tanimoto similarity
    """

    return DataStructs.TanimotoSimilarity(true_fp, gen_fp)


def sim_3d(gen_mol, true_mol):
    """
    Calculates 3D similarities

    Parameters
    ----------
        gen_mol: RDKit Mol object
            Molecule generated by method
        true_mol: RDKit Mol object
            Molecule from crystal data or hits

    Returns
    -------
        aligned: boolean on whether alignment worked (requires common substructure)
        sim_3d: float of 3D Tanimoto similarity
    """

    # Done without alignment
    sim_3d = Chem.rdShapeHelpers.ShapeTanimotoDist(gen_mol, true_mol)

    return sim_3d


def ave_sim_2d_to_chembl(gen_fp, chembl_fp_list):
    """
    Calculates 2D similarities using RDKit fingerprints of generated and true compounds

    Parameters
    ----------
        gen_fp: RDKit fingerprint object
            Fingerprint of generated molecule
        chembl_mol_list: List of RDKit fingerprints objects
            Fingerprint of molecule from ChEMBL data

    Returns
    -------
        ave_sim: float of average 2D Tanimoto similarity
    """

    sim_list = []

    for chembl_fp in chembl_fp_list:
        sim_list.append(sim_2d(gen_fp, chembl_fp))

    if len(sim_list) != 0:
        ave_sim = sum(sim_list) / len(sim_list)
    else:
        ave_sim = None

    return sim_list, ave_sim


def standardize_cmpd(smi):
    """
    Standardizes, canonicalizes, and de-salts SMILES input

    Parameters
    ----------
        smi_list: str
            SMILES string to be standardized

    Returns
    -------
        standard_smi: standardized SMILES
        standard_mol: standardized RDKit Mol object
    """

    standard_smi = None
    standard_mol = None

    mol = Chem.MolFromSmiles(smi)

    try:
        # Standardization: reionize, remove Hydrogens, disconnect metals
        Chem.rdmolops.Cleanup(mol)
        # Checks validity of molecule
        Chem.rdmolops.SanitizeMol(mol)

        # Remove stereochemistry
        Chem.rdmolops.RemoveStereochemistry(mol)

        # Get main molecule if fragments/salts in mol
        mol_parent = Chem.MolStandardize.rdMolStandardize.FragmentParent(mol)

        # Neutralize charges
        mol_neutral = Chem.MolStandardize.rdMolStandardize.Uncharger().uncharge(
            mol_parent
        )

        standard_smi = Chem.MolToSmiles(mol_neutral)
        standard_mol = mol_neutral

    except Exception as e:
        print("Error standardizing:", e)

    return standard_smi, standard_mol


def get_smallest_atom_dist(coords, mol):
    """
    Gets the smallest distance of any atom in a molecule to a given set of coordinates (or COM coordinates)

    Parameters
    ----------
        coords: list
            3D coordinates in x,y,z format
        mol: RDKit Mol object
            Molecule to parse through to find closest atom to given coords

    Returns
    -------
        min_dist: float of L2 norm of x,y,z coordinates to get distance
    """

    if mol is None:
        return None

    mol = mol.GetConformer()
    atomic_positions = mol.GetPositions()

    min_dist = None
    for atomic_position in atomic_positions:
        dist = np.linalg.norm(coords - atomic_position)
        if min_dist is None or min_dist > dist:
            min_dist = dist

    return min_dist


class task1Metrics:
    def __init__(self, output_df_for_prot):
        """
        Task 1 specific metrics for unseen targets with specific requirements

        Parameters
        ----------
            output_df_for_prot: pandas DataFrame
                Output DataFrame from with per compound scores from class metricCalcs, filtered for one protein
        """

        # Only use samples that have SDF files that exist
        self.output_df_for_prot = output_df_for_prot[
            ~output_df_for_prot["mol_pred"].astype(str).str.contains("Errno")
        ]

        self.prot_file = list(self.output_df_for_prot["mol_cond"].unique())

    def prot_1(self):
        """
        Checks similarity of generated compounds to ligand crystal structure and their difference depending on WT or mutated input protein
        """

        target_specific_metrics = pd.DataFrame()

        WT_file = None
        mut_file = None

        for file in self.prot_file:
            if "170" not in file:
                WT_file = file
            else:
                mut_file = file

        WT_struct = PDB.PDBParser().get_structure("WT_prot", WT_file)
        mut_struct = PDB.PDBParser().get_structure("mut_prot", mut_file)

        # Get coordinates of residue 170
        WT_coords = prot_com(WT_struct[0].get_residues(), "170")
        mut_coords = prot_com(mut_struct[0].get_residues(), "170")

        # Check distance of min molecule atom to residue 170
        struct_file = list(self.output_df_for_prot["mol_true"].unique())[0]
        WT_struct_mol = [mol for mol in Chem.SDMolSupplier(struct_file) if mol != None]
        WT_struct_dist_to_WT_res = get_smallest_atom_dist(WT_coords, WT_struct_mol[0])
        WT_struct_dist_to_mut_res = get_smallest_atom_dist(mut_coords, WT_struct_mol[0])

        WT_mol_fp = Chem.RDKFingerprint(WT_struct_mol[0])

        # Find similarity of generated compounds to crystal ligand
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            # Get min distances from WT and mutated residues
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]
            gen_struct_min_dist_WT = get_smallest_atom_dist(WT_coords, gen_mol[0])
            gen_struct_min_dist_mut = get_smallest_atom_dist(mut_coords, gen_mol[0])

            # Find Tanimoto similarity to crystal structure
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim = sim_2d(gen_fp, WT_mol_fp)

            tmp_df["true_min_dist_to_WT_res"] = WT_struct_dist_to_WT_res
            tmp_df["true_min_dist_to_mut_res"] = WT_struct_dist_to_mut_res
            tmp_df["gen_min_dist_to_WT_res"] = gen_struct_min_dist_WT
            tmp_df["gen_min_dist_to_mut_res"] = gen_struct_min_dist_mut
            tmp_df["gen_true_sim"] = sim

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_2(self):
        """
        Checks similarity of generated compounds and interactions re-created with certain residues
        """

        target_specific_metrics = pd.DataFrame()

        file_1w6k = None
        file_1w6j = None

        for file in self.prot_file:
            if "1w6j" in file:
                file_1w6k = file
            else:
                file_1w6j = file

        # Get PDB parser structures
        struct_1w6k = PDB.PDBParser().get_structure("1w6k", file_1w6k)
        struct_1w6j = PDB.PDBParser().get_structure("1w6j", file_1w6j)

        # Get coordinates of residue 455
        coords_1w6k_455 = prot_com(struct_1w6k[0].get_residues(), "455")
        coords_1w6j_455 = prot_com(struct_1w6j[0].get_residues(), "455")

        # Get coordinates of residue 237
        coords_1w6k_237 = prot_com(struct_1w6k[0].get_residues(), "237")
        coords_1w6j_237 = prot_com(struct_1w6j[0].get_residues(), "237")

        # Get coordinates of residue 233
        coords_1w6k_233 = prot_com(struct_1w6k[0].get_residues(), "233")
        coords_1w6j_233 = prot_com(struct_1w6j[0].get_residues(), "233")

        # Get coordinates of residue 524
        coords_1w6k_524 = prot_com(struct_1w6k[0].get_residues(), "524")
        coords_1w6j_524 = prot_com(struct_1w6j[0].get_residues(), "524")

        mol_1w6k = None
        mol_1w6j = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "1w6k" in file:
                mol_1w6k = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "1w6j" in file:
                mol_1w6j = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        # Get minimum distances from 1w6j and 1w6k residues
        # 455
        crystal_distance_min_1w6k_455 = get_smallest_atom_dist(
            coords_1w6k_455, mol_1w6k
        )
        crystal_distance_min_1w6j_455 = get_smallest_atom_dist(
            coords_1w6k_455, mol_1w6j
        )
        # 237
        crystal_distance_min_1w6k_237 = get_smallest_atom_dist(
            coords_1w6k_237, mol_1w6k
        )
        crystal_distance_min_1w6j_237 = get_smallest_atom_dist(
            coords_1w6j_237, mol_1w6j
        )
        # 233
        crystal_distance_min_1w6k_233 = get_smallest_atom_dist(
            coords_1w6k_233, mol_1w6k
        )
        crystal_distance_min_1w6j_233 = get_smallest_atom_dist(
            coords_1w6j_233, mol_1w6j
        )
        # 524
        crystal_distance_min_1w6k_524 = get_smallest_atom_dist(
            coords_1w6k_524, mol_1w6k
        )
        crystal_distance_min_1w6j_524 = get_smallest_atom_dist(
            coords_1w6j_524, mol_1w6j
        )

        fp_1w6k = Chem.RDKFingerprint(mol_1w6k)
        fp_1w6j = Chem.RDKFingerprint(mol_1w6j)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            # Get minimum atom distances from 1w6j and 1w6k residues
            # 455
            distance_min_1w6k_455 = get_smallest_atom_dist(coords_1w6k_455, gen_mol)
            distance_min_1w6j_455 = get_smallest_atom_dist(coords_1w6j_455, gen_mol)

            # 237
            distance_min_1w6k_237 = get_smallest_atom_dist(coords_1w6k_237, gen_mol)
            distance_min_1w6j_237 = get_smallest_atom_dist(coords_1w6j_237, gen_mol)

            # 233
            distance_min_1w6k_233 = get_smallest_atom_dist(coords_1w6k_233, gen_mol)
            distance_min_1w6j_233 = get_smallest_atom_dist(coords_1w6j_233, gen_mol)

            # 524
            distance_min_1w6k_524 = get_smallest_atom_dist(coords_1w6k_524, gen_mol)
            distance_min_1w6j_524 = get_smallest_atom_dist(coords_1w6j_524, gen_mol)

            # Find Tanimoto similarity to crystal structure
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_1w6k = sim_2d(fp_1w6k, gen_fp)
            sim_1w6j = sim_2d(fp_1w6j, gen_fp)

            tmp_df["true_min_dist_to_1w6k_res_455"] = crystal_distance_min_1w6k_455
            tmp_df["true_min_dist_to_1w6j_res_455"] = crystal_distance_min_1w6j_455

            tmp_df["true_min_dist_to_1w6k_res_237"] = crystal_distance_min_1w6k_237
            tmp_df["true_min_dist_to_1w6j_res_237"] = crystal_distance_min_1w6j_237

            tmp_df["true_min_dist_to_1w6k_res_233"] = crystal_distance_min_1w6k_233
            tmp_df["true_min_dist_to_1w6j_res_233"] = crystal_distance_min_1w6j_233

            tmp_df["true_min_dist_to_1w6k_res_524"] = crystal_distance_min_1w6k_524
            tmp_df["true_min_dist_to_1w6j_res_524"] = crystal_distance_min_1w6j_524

            tmp_df["gen_min_dist_to_1w6k_res_455"] = distance_min_1w6k_455
            tmp_df["gen_min_dist_to_1w6j_res_455"] = distance_min_1w6j_455

            tmp_df["gen_min_dist_to_1w6k_res_237"] = distance_min_1w6k_237
            tmp_df["gen_min_dist_to_1w6j_res_237"] = distance_min_1w6j_237

            tmp_df["gen_min_dist_to_1w6k_res_233"] = distance_min_1w6k_233
            tmp_df["gen_min_dist_to_1w6j_res_233"] = distance_min_1w6j_233

            tmp_df["gen_min_dist_to_1w6k_res_524"] = distance_min_1w6k_524
            tmp_df["gen_min_dist_to_1w6j_res_524"] = distance_min_1w6j_524

            tmp_df["gen_true_sim_1w6k"] = sim_1w6k
            tmp_df["gen_true_sim_1w6j"] = sim_1w6j

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_3(self):
        """
        Checks if compounds generated are different given different protein conformations
        """

        target_specific_metrics = pd.DataFrame()

        mol_5cqh = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "5cqh" in file:
                mol_5cqh = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_5cqh = Chem.RDKFingerprint(mol_5cqh)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]

            # Find Tanimoto similarity to crystal structure
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_5cqh = sim_2d(fp_5cqh, gen_fp)

            tmp_df["gen_true_sim_5cqh"] = sim_5cqh

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_4(self):
        """
        Checks if inclusion of Fe affects compounds generated by assessing distance to Fe and similarity to inhibitor
        """

        target_specific_metrics = pd.DataFrame()

        file_3rde_Fe = None

        for file in self.prot_file:
            if "Fe" in file:
                file_3rde_Fe = file

        struct_3rde_Fe = PDB.PDBParser().get_structure("3rde_fe", file_3rde_Fe)

        mol_3rde = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "3rde" in file:
                mol_3rde = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        # Check distance of input molecule to Fe
        fe_com = [
            i.center_of_mass()
            for i in struct_3rde_Fe[0].get_residues()
            if i.get_id()[0] == "H_FE2"
        ][0]
        crystal_distance_min_fe = get_smallest_atom_dist(fe_com, mol_3rde)

        fp_3rde = Chem.RDKFingerprint(mol_3rde)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]

            # Find Tanimoto similarity to crystal structure
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_3rde = sim_2d(fp_3rde, gen_fp)

            # Distance to Fe
            gen_distance_to_fe = get_smallest_atom_dist(fe_com, gen_mol[0])

            tmp_df["true_min_dist_to_Fe"] = crystal_distance_min_fe
            tmp_df["gen_true_sim_3rde"] = sim_3rde
            tmp_df["gen_min_dist_to_Fe"] = gen_distance_to_fe

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_5(self):
        """
        Compare similarities to 3HII and 3HIG ligands and whether they are different for apo 3HI7
        """

        target_specific_metrics = pd.DataFrame()

        mol_3hii = None
        mol_3hig = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "3hii" in file:
                mol_3hii = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "3hig" in file:
                mol_3hig = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_3hii = Chem.RDKFingerprint(mol_3hii)
        fp_3hig = Chem.RDKFingerprint(mol_3hig)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]

            # Find Tanimoto similarity to crystal structure
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_3hii = sim_2d(fp_3hii, gen_fp)
            sim_3hig = sim_2d(fp_3hig, gen_fp)

            tmp_df["gen_true_sim_3hii"] = sim_3hii
            tmp_df["gen_true_sim_3hig"] = sim_3hig

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_6(self):
        """
        Contain ligands that have similar interactions but bind in opposite directions
        Assess if similar interactions re-created and if COM shifted depending on input protein
        """

        target_specific_metrics = pd.DataFrame()

        mol_6ryo = None
        mol_6ryp = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "6ryo" in file:
                mol_6ryo = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "6ryp" in file:
                mol_6ryp = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        mol_6ryo_com = mol_com(mol_6ryo)
        mol_6ryp_com = mol_com(mol_6ryp)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]

            if mol_6ryo_com is not None:
                tmp_df["6ryo_gen_mol_min_dist"] = get_smallest_atom_dist(
                    mol_6ryo_com, gen_mol[0]
                )
            if mol_6ryp_com is not None:
                tmp_df["6ryp_gen_mol_min_dist"] = get_smallest_atom_dist(
                    mol_6ryp_com, gen_mol[0]
                )

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_7(self):
        """
        Assess if hinge binding interactions found in both cases
        Assess if 4l9i compounds are "selective" over 4mk0 (re-created interactions and no clashes)
        """

        target_specific_metrics = pd.DataFrame()

        mol_4l9i = None
        mol_4mk0 = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "4l9i" in file:
                mol_4l9i = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "4mk0" in file:
                mol_4mk0 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_4l9i = Chem.RDKFingerprint(mol_4l9i)

        # Hinge interactions for 4L9I with Met 267 and 4MK0 with Met 274
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            recreated_hbond = row["PLIP"]["hbond"]["interaction_frac"]

            tmp_df["recreated_hbonds"] = recreated_hbond

            # Clashes already under number_clashes from posebusters metrics

            # Similarity to 4l9i selective compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_4l9i = sim_2d(fp_4l9i, gen_fp)

            tmp_df["sim_gen_4l9i"] = sim_4l9i

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_8(self):
        """
        Assess if generated compounds are similar to bound inhibitor
        """

        target_specific_metrics = pd.DataFrame()

        # Piperazine important for activity, check if similar substructure is present
        pattern = Chem.MolFromSmarts("C~1~C~N~C~C~N~1")

        mol_4q6r = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "4q6r" in file:
                mol_4q6r = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_4q6r = Chem.RDKFingerprint(mol_4q6r)

        # Check similarity to crystal compound
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to 4q6r selective compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_4q6r = sim_2d(fp_4q6r, gen_fp)

            tmp_df["sim_gen_4q6r"] = sim_4q6r

            # Check if piperazine ring present
            tmp_df["has_piperazine"] = gen_mol[0].HasSubstructMatch(pattern)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_9(self):
        """
        Affects of inclusion/exclusion of Zn and H2O on generated compounds (distances to Zn and H2O of generated compounds)
        """

        target_specific_metrics = pd.DataFrame()

        struct_min_dist_to_Zn_1pl6 = None
        struct_min_dist_to_water_1pl6 = None
        distance_min_1pl6_Zn = None
        distance_min_1pl6_H2O = None
        distance_min_1pl7_Zn = None
        distance_min_1pl7_H2O = None

        # Find minimum distance of compound atom to Zn and H2O coordinates
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            prot_file = row["mol_cond"]

            file_1pl6 = None
            file_1pl7 = None

            if "1pl6" in prot_file:
                file_1pl6 = prot_file
            else:
                file_1pl7 = prot_file

            if file_1pl6 is not None:
                # Check distance of molecule to Zn and water - ligand only in 1pl6
                struct_file = list(self.output_df_for_prot["mol_true"].unique())[0]
                struct_mol_1pl6 = [
                    mol for mol in Chem.SDMolSupplier(struct_file) if mol != None
                ][0]

                struct_1pl6 = PDB.PDBParser().get_structure("1pl6_prot", file_1pl6)

                if "Zn" in file_1pl6:
                    # Get coordinates of Zn
                    struct_1pl6_Zn_coords = [
                        i.center_of_mass()
                        for i in struct_1pl6[0].get_residues()
                        if i.get_id()[0] == "H_ZN"
                    ][0]
                    struct_min_dist_to_Zn_1pl6 = get_smallest_atom_dist(
                        struct_1pl6_Zn_coords, struct_mol_1pl6
                    )
                    distance_min_1pl6_Zn = get_smallest_atom_dist(
                        struct_1pl6_Zn_coords, gen_mol
                    )

                if "water" in file_1pl6:
                    # Get coordinates of H2O
                    struct_1pl6_water_coords = [
                        i.center_of_mass()
                        for i in struct_1pl6[0].get_residues()
                        if i.get_id()[0] == "W"
                    ][0]
                    struct_min_dist_to_water_1pl6 = get_smallest_atom_dist(
                        struct_1pl6_water_coords, struct_mol_1pl6
                    )
                    distance_min_1pl6_H2O = get_smallest_atom_dist(
                        struct_1pl6_water_coords, gen_mol
                    )

            elif file_1pl7 is not None:
                struct_1pl7_apo = PDB.PDBParser().get_structure("1pl7_prot", file_1pl7)

                if "Zn" in file_1pl7:
                    # Get coordinates of Zn
                    struct_1pl7_apo_Zn_coords = [
                        i.center_of_mass()
                        for i in struct_1pl7_apo[0].get_residues()
                        if i.get_id()[0] == "H_ZN"
                    ][0]
                    distance_min_1pl7_Zn = get_smallest_atom_dist(
                        struct_1pl7_apo_Zn_coords, gen_mol
                    )

                if "water" in file_1pl7:
                    # Get coordinates of H2O
                    struct_1pl7_apo_water_coords = [
                        i.center_of_mass()
                        for i in struct_1pl7_apo[0].get_residues()
                        if i.get_id()[0] == "W"
                    ][0]
                    distance_min_1pl7_H2O = get_smallest_atom_dist(
                        struct_1pl7_apo_water_coords, gen_mol
                    )

            tmp_df["true_min_dist_to_Zn_1pl6"] = struct_min_dist_to_Zn_1pl6
            tmp_df["true_min_dist_to_H2O_1pl6"] = struct_min_dist_to_water_1pl6

            tmp_df["gen_min_dist_to_Zn_1pl6"] = distance_min_1pl6_Zn
            tmp_df["gen_min_dist_to_H2O_1pl6"] = distance_min_1pl6_H2O
            tmp_df["gen_min_dist_to_Zn_1pl7"] = distance_min_1pl7_Zn
            tmp_df["gen_min_dist_to_H2O_1pl7"] = distance_min_1pl7_H2O

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_10(self):
        """
        Similarity to bound structure
        """

        target_specific_metrics = pd.DataFrame()

        mol_6r7d = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "6r7d" in file:
                mol_6r7d = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_6r7d = Chem.RDKFingerprint(mol_6r7d)

        # Check similarity to crystal compound
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to 6r7d selective compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            sim_6r7d = sim_2d(fp_6r7d, gen_fp)

            tmp_df["sim_gen_6r7d"] = sim_6r7d

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_11(self):
        """
        Assess if interactions with Zn reproduced
        """

        target_specific_metrics = pd.DataFrame()
        
        Zn_1itu_struct = [PDB.PDBParser().get_structure("1itu_prot",i) for i in self.output_df_for_prot["mol_cond"].unique() if "Zn" in i and "1itu" in i][0]
        Zn_1itq_struct = [PDB.PDBParser().get_structure("1itq_prot",i) for i in self.output_df_for_prot["mol_cond"].unique() if "Zn" in i and "1itq" in i][0]
        
        Zn_coords_1itu = [
                    i.center_of_mass()
                    for i in Zn_1itu_struct[0].get_residues()
                    if i.get_id()[0] == "H_ZN"
                ][0]
        Zn_coords_1iqt = [
                    i.center_of_mass()
                    for i in Zn_1itq_struct[0].get_residues()
                    if i.get_id()[0] == "H_ZN"
                ][0]
        
        # Check distance of molecule to Zn and water - ligand only in 1pl6
        struct_file = list(self.output_df_for_prot["mol_true"].unique())[0]
        struct_mol_1itu = [
            mol for mol in Chem.SDMolSupplier(struct_file) if mol != None
        ][0]

        struct_dist_to_Zn_1itu = get_smallest_atom_dist(
            Zn_coords_1itu, struct_mol_1itu
        )

        # Find distance of compound to Zn
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            prot_file = row["mol_cond"]

            file_1itu = None
            file_1itq = None

            if "1itu" in prot_file:
                file_1itu = prot_file
            else:
                file_1itq = prot_file

            if file_1itu is not None:
                
                distance_min_Zn = get_smallest_atom_dist(
                    Zn_coords_1itu, gen_mol
                )

            elif file_1itq is not None:
                distance_min_Zn = get_smallest_atom_dist(
                    Zn_coords_1iqt, gen_mol
                )

            tmp_df["true_min_dist_to_Zn_1itu"] = struct_dist_to_Zn_1itu
            tmp_df["gen_min_dist_to_Zn"] = distance_min_Zn

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics


    def prot_12(self):
        """
        Assess if the same interactions are created as the bound inhibitor through PLIP and importance of Zn
        """

        target_specific_metrics = pd.DataFrame()

        mol_2v77 = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "2v77" in file:
                mol_2v77 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_2v77 = Chem.RDKFingerprint(mol_2v77)

        file_2v77_Zn = None
        file_2v77_no_Zn = None

        for file in self.prot_file:
            if "Zn" in file:
                file_2v77_Zn = file

        struct_2v77_Zn = PDB.PDBParser().get_structure("2v77_zn", file_2v77_Zn)

        # Check distance of input molecule to Zn
        zn_com = [
            i.center_of_mass()
            for i in struct_2v77_Zn[0].get_residues()
            if i.get_id()[0] == "H_ZN"
        ][0]
        crystal_distance_min_zn = get_smallest_atom_dist(zn_com, mol_2v77)

        # Check similarity to crystal compound
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to 2v77 compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]
            gen_fp = Chem.RDKFingerprint(gen_mol)
            sim_2v77 = sim_2d(fp_2v77, gen_fp)

            tmp_df["sim_gen_2v77"] = sim_2v77

            tmp_df["true_min_dist_to_Zn_2v77"] = crystal_distance_min_zn
            tmp_df["gen_dist_to_Zn_2v77"] = get_smallest_atom_dist(zn_com, gen_mol)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_13(self):
        """
        Assess whether there are differences in generated compounds between chloropyrimidine crystal structure and purinetrione structures
        """

        target_specific_metrics = pd.DataFrame()

        mol_2c97, fp_2c97 = None, None
        mol_2c9b, fp_2c9b = None, None
        mol_2c92, fp_2c92 = None, None
        mol_2c94, fp_2c94 = None, None
        mol_2c9d, fp_2c9d = None, None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "2c97" in file:
                mol_2c97 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
                fp_2c97 = Chem.RDKFingerprint(mol_2c97)
            elif "2c9b" in file:
                mol_2c9b = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
                fp_2c9b = Chem.RDKFingerprint(mol_2c9b)
            elif "2c92" in file:
                mol_2c92 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
                fp_2c92 = Chem.RDKFingerprint(mol_2c92)
            elif "2c94" in file:
                mol_2c94 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
                fp_2c94 = Chem.RDKFingerprint(mol_2c94)
            elif "2c9d" in file:
                mol_2c9d = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
                fp_2c9d = Chem.RDKFingerprint(mol_2c9d)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])

            tmp_df["sim_gen_2c97"] = None
            tmp_df["sim_gen_2c9b"] = None
            tmp_df["sim_gen_2c92"] = None
            tmp_df["sim_gen_2c94"] = None
            tmp_df["sim_gen_2c9d"] = None

            if fp_2c97 is not None:
                tmp_df["sim_gen_2c97"] = sim_2d(fp_2c97, gen_fp)
            if fp_2c9b is not None:
                tmp_df["sim_gen_2c9b"] = sim_2d(fp_2c9b, gen_fp)
            if fp_2c92 is not None:
                tmp_df["sim_gen_2c92"] = sim_2d(fp_2c92, gen_fp)
            if fp_2c94 is not None:
                tmp_df["sim_gen_2c94"] = sim_2d(fp_2c94, gen_fp)
            if fp_2c9d is not None:
                tmp_df["sim_gen_2c9d"] = sim_2d(fp_2c9d, gen_fp)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_14(self):
        """
        If both binding modes can be found using COM
        """

        target_specific_metrics = pd.DataFrame()

        mol_5jwa = None
        mol_5jwc = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "5jwa" in file:
                mol_5jwa = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            else:
                mol_5jwc = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        mol_5jwa_com = mol_com(mol_5jwa)
        mol_5jwc_com = mol_com(mol_5jwc)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to 2v77 compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            gen_com = mol_com(gen_mol)

            if gen_com is not None and mol_5jwa_com is not None:
                tmp_df["5jwa_gen_mol_com_dist"] = np.linalg.norm(gen_com - mol_5jwa_com)
            if gen_com is not None and mol_5jwc_com is not None:
                tmp_df["5jwc_gen_mol_com_dist"] = np.linalg.norm(gen_com - mol_5jwc_com)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_15(self):
        """
        Whether compounds similar to crystal structures are generated
        """

        target_specific_metrics = pd.DataFrame()

        mol_6z80 = None
        mol_6z85 = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "6z80" in file:
                mol_6z80 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            else:
                mol_6z85 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_6z80 = Chem.RDKFingerprint(mol_6z80)
        fp_6z85 = Chem.RDKFingerprint(mol_6z85)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to 2v77 compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            tmp_df["6z80_gen_sim"] = sim_2d(fp_6z80, gen_fp)
            tmp_df["6z85_gen_sim"] = sim_2d(fp_6z85, gen_fp)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_16(self):
        """
        Similarity to input compounds and whether both binding modes can be generated
        """

        target_specific_metrics = pd.DataFrame()

        mol_5yjw_allosteric = None
        mol_5yjw_active = None
        mol_5yjw = None
        mol_5yjy = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "5yjw" and "allosteric" in file:
                mol_5yjw_allosteric = [
                    mol for mol in Chem.SDMolSupplier(file) if mol != None
                ][0]
            elif "5yjw" and "active" in file:
                mol_5yjw_active = [
                    mol for mol in Chem.SDMolSupplier(file) if mol != None
                ][0]
            elif "5yjx" in file:
                mol_5yjw = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "5yjy" in file:
                mol_5yjy = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        mol_5yjw_allosteric_com = mol_com(mol_5yjw_allosteric)
        mol_5yjw_active_com = mol_com(mol_5yjw_active)
        mol_5yjx_com = mol_com(mol_5yjw)
        mol_5yjy_com = mol_com(mol_5yjy)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # COM of compounds
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            gen_com = mol_com(gen_mol)

            if gen_com is not None and mol_5yjw_allosteric_com is not None:
                tmp_df["5yjw_allosteric_gen_mol_com_dist"] = np.linalg.norm(
                    gen_com - mol_5yjw_allosteric_com
                )
            if gen_com is not None and mol_5yjw_active_com is not None:
                tmp_df["5yjw_active_gen_mol_com_dist"] = np.linalg.norm(
                    gen_com - mol_5yjw_active_com
                )
            if gen_com is not None and mol_5yjx_com is not None:
                tmp_df["5yjx_gen_mol_com_dist"] = np.linalg.norm(gen_com - mol_5yjx_com)
            if gen_com is not None and mol_5yjy_com is not None:
                tmp_df["5yjy_gen_mol_com_dist"] = np.linalg.norm(gen_com - mol_5yjy_com)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_17(self):
        """
        Similarity of ligands created in apo and holo form with/without SF4 cofactor
        """

        target_specific_metrics = pd.DataFrame()

        mol_6xi9 = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "6xi9" in file:
                mol_6xi9 = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_6xi9 = Chem.RDKFingerprint(mol_6xi9)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            tmp_df["6xi9_gen_sim"] = sim_2d(fp_6xi9, gen_fp)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_18(self):
        """
        Similarity of sizes/interactions to benzoate and acetate inhibitors and whether changing FMN/protein conformation changes molecules generated
        """

        target_specific_metrics = pd.DataFrame()

        mol_1kqb = None
        mol_1kqc = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "1kqb" in file:
                mol_1kqb = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            else:
                mol_1kqc = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_1kqb = Chem.RDKFingerprint(mol_1kqb)
        fp_1kqc = Chem.RDKFingerprint(mol_1kqc)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            tmp_df["1kqc_gen_sim"] = sim_2d(fp_1kqc, gen_fp)
            tmp_df["1kqb_gen_sim"] = sim_2d(fp_1kqb, gen_fp)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_19(self):
        """
        Whether inclusion of Ca produces more acidic compounds and if inclusion/exclusion of water changes the size compounds generated
        """

        target_specific_metrics = pd.DataFrame()

        mol_4kxb = None
        mol_4kxc = None
        mol_4kxd = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "4kxb" in file:
                mol_4kxb = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            elif "4kxc" in file:
                mol_4kxc = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]
            else:
                mol_4kxd = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]

            # Get information for acidic and basic groups
            fdef_name = os.path.join(RDConfig.RDDataDir, "BaseFeatures.fdef")
            rdmol_featurizer = ChemicalFeatures.BuildFeatureFactory(fdef_name)
            rdmol_feats = rdmol_featurizer.GetFeaturesForMol(gen_mol)

            tmp_df["hasAcidic"] = False
            tmp_df["hasBasic"] = False
            # Get acid/base information
            for feats in rdmol_feats:
                if (feats.GetFamily() == "NegIonizable") & (
                    feats.GetType() == "AcidicGroup"
                ):
                    tmp_df["hasAcidic"] = True
                if (feats.GetFamily() == "PosIonizable") & (
                    feats.GetType() == "BasicGroup"
                ):
                    tmp_df["hasBasic"] = True

            tmp_df["gen_mol_vol"] = Chem.AllChem.ComputeMolVolume(gen_mol)
            tmp_df["4kxb_mol_vol"] = Chem.AllChem.ComputeMolVolume(mol_4kxb)
            tmp_df["4kxc_mol_vol"] = Chem.AllChem.ComputeMolVolume(mol_4kxc)
            tmp_df["4kxd_mol_vol"] = Chem.AllChem.ComputeMolVolume(mol_4kxd)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def prot_20(self):
        """
        Whether distortion of haeme on binding abietic acid produces more compounds like abietic acid
        """

        target_specific_metrics = pd.DataFrame()

        mol_5iki = None

        for file in list(self.output_df_for_prot["mol_true"].unique()):
            if "5iki" in file:
                mol_5iki = [mol for mol in Chem.SDMolSupplier(file) if mol != None][0]

        fp_5iki = Chem.RDKFingerprint(mol_5iki)

        # Check similarity to crystal compounds
        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            # Similarity to compound
            gen_sdf_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(gen_sdf_file) if mol != None][
                0
            ]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            tmp_df["5iki_gen_sim"] = sim_2d(fp_5iki, gen_fp)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics


class task2Metrics:
    def __init__(
        self,
        output_df_for_prot,
        chembl_csv_dir="Benchmarking_Tasks/Task2",
    ):
        """
        Task 2 specific metrics for unseen targets with specific requirements

        Parameters
        ----------
            output_df_for_prot: pandas DataFrame
                Output DataFrame from with per compound scores from class metricCalcs, filtered for one protein
            chembl_csv_dir: str
                Directory containing Task2 csv files containing compounds from ChEMBL
        """

        # Only use samples that have SDF files that exist
        self.output_df_for_prot = output_df_for_prot[
            ~output_df_for_prot["mol_pred"].astype(str).str.contains("Errno")
        ]
        self.prot_file = list(self.output_df_for_prot["mol_cond"].unique())

        self.chembl_dir = chembl_csv_dir

    def sequence_align_structures(self, struct_1, struct_2):
        """
        Performs sequence alignment of two protein structures. Taken heavily from https://gist.github.com/JoaoRodrigues/e3a4f2139d10888c679eb1657a4d7080

        Parameters
        ----------
            struct_1: BioPython Structure object
                Reference structure to align to
            struct_2: BioPython Structure object
                Sample structure being aligned

        Returns
        -------
            struct_1_ca_list, struct_2_ca_list: lists of mapped alpha Carbon residues from structure 1 to structure 2
        """

        if struct_1 is None or struct_2 is None:
            return None, None

        def get_seq(structure):
            seq = []
            for r in structure.get_residues():
                if PDB.Polypeptide.is_aa(r):
                    try:
                        seq_name = (
                            r.id,
                            Data.IUPACData.protein_letters_3to1[
                                r.resname[0].upper() + r.resname[1:].lower()
                            ],
                        )
                        seq.append(seq_name)
                    except:
                        warnings.warn("Residue not an amino acid: " + str(r.resname))
            return seq

        sequence_1 = get_seq(struct_1)
        sequence_2 = get_seq(struct_2)

        sequence_res_1 = "".join([i[1] for i in sequence_1])
        sequence_res_2 = "".join([i[1] for i in sequence_2])

        aligner = Align.PairwiseAligner()
        alignments = aligner.align(sequence_res_1, sequence_res_2)

        best_alignment = alignments[0]
        aligned_1, aligned_2 = best_alignment

        # Map IDs to make consistent
        mapping = {}
        aa_i_1, aa_i_2 = 0, 0
        for aln_i, (aa_aln_1, aa_aln_2) in enumerate(zip(aligned_1, aligned_2)):
            if aa_aln_1 == "-":
                if aa_aln_2 != "-":
                    aa_i_2 += 1
            elif aa_aln_2 == "-":
                if aa_aln_1 != "-":
                    aa_i_1 += 1
            else:
                assert sequence_1[aa_i_1][1] == aa_aln_1
                assert sequence_2[aa_i_2][1] == aa_aln_2
                mapping[sequence_1[aa_i_1][0]] = sequence_2[aa_i_2][0]
                aa_i_1 += 1
                aa_i_2 += 1

        # Align sequences
        struct_1_ca_list, struct_2_ca_list = [], []
        for ca_list_1 in mapping:
            try:
                struct_1_ca = struct_1[0]["A"][ca_list_1]["CA"]
                struct_2_ca = struct_2[0]["A"][mapping[ca_list_1]]["CA"]
            except:
                continue

            struct_1_ca_list.append(struct_1_ca)
            struct_2_ca_list.append(struct_2_ca)

        return struct_1_ca_list, struct_2_ca_list

    def align_structures(self, pdb_file, lig_file, ref_CA_list, sample_CA_list):
        """
        Aligns two structures

        Parameters
        ----------
            pdb_file: str
                Path to sample PDB file
            lig_file: str
                Path to ligand or generated sdf file
            ref_CA_list: list
                Reference structure alpha Carbon list
            sample_CA_list: list
                Renumbered alpha Carbon list for sample structure

        Returns
        -------
            combined_struct: BioPython Structure object aligned to reference
        """

        # Write temporary combined file with generated ligand
        # If NoneType, will error so return None as structure
        try:
            combine.combine(pdb_file, lig_file, "tmp_comb_struct_align.pdb")
            combined_struct = PDB.PDBParser().get_structure(
                "sample", "tmp_comb_struct_align.pdb"
            )
            os.remove("tmp_comb_struct_align.pdb")

            # Superimpose matching residues with given ligand
            si = PDB.Superimposer()
            si.set_atoms(ref_CA_list, sample_CA_list)
            si.apply(combined_struct[0].get_atoms())
        except:
            combined_struct = None

        return combined_struct

    def align_and_get_com_interactions(
        self, pdb_file, ref_pdb_file, lig_file, ref_CA_list, sample_CA_list
    ):
        """
        Aligns two structures then COM of ligand and interaction dictionary using PLIP

        Parameters
        ----------
            pdb_file: str
                Path to sample PDB file
            ref_pdb_file: str
                Path to reference PDB (to be aligned to this structure)
            lig_file: str
                Path to ligand or generated sdf file
            ref_CA_list: list
                Reference structure alpha Carbon list
            sample_CA_list: list
                Renumbered alpha Carbon list for sample structure

        Returns
        -------
            gen_lig_aligned_COM: list of x,y,z coordinates of the center-of-mass of generated ligand
            ref_interactions: dictionary of interactions from PLIP for the reference structure
        """

        combined_struct = self.align_structures(
            pdb_file, lig_file, ref_CA_list, sample_CA_list
        )

        if combined_struct is not None:
            # Save lig file to get interactions
            io = PDB.PDBIO()
            io.set_structure(combined_struct[0]["Z"])
            io.save("test_sdf_superimpose_lig_only.pdb")

            # Ligand COM only (chain Z as defined in combine.combine)
            gen_lig_aligned_COM = list(combined_struct[0]["Z"].center_of_mass())

            # Check if interactions re-created for generated ligand and reference PDB
            ref_interactions = recreatedPLIP(
                ref_pdb_file, "test_sdf_superimpose_lig_only.pdb"
            ).interaction_dict

            os.remove("test_sdf_superimpose_lig_only.pdb")

            return gen_lig_aligned_COM, ref_interactions

        return None, None

    def ITK_selectivity(self):
        """
        Calculates ITK selectivity over LCK and AurB
        First checks if Hydrogen bonds are made with the hinge region for ITK and AurB and interaction with Arg32 for LCK
        Then checks if there is an interaction/closeness to Val 419 in ITK (Leu 138 in AurB)
        Additional analysis later on clashes
        """

        chembl_cmpds = pd.read_csv(
            os.path.join(self.chembl_dir, "ITK_LCK_AurB_data.csv")
        )

        target_specific_metrics = pd.DataFrame()

        ITK_PDB = None
        AurB_PDB = None

        for file in self.prot_file:
            if "4l7s" in file:
                ITK_PDB = file
            elif "4af3" in file:
                AurB_PDB = file

        struct_ITK = PDB.PDBParser().get_structure("ref", ITK_PDB)
        struct_AurB = PDB.PDBParser().get_structure("sample", AurB_PDB)

        ITK_com_val419 = prot_com(struct_ITK[0].get_residues(), "419")
        AurB_com_leu138 = prot_com(struct_AurB[0].get_residues(), "138")

        # Get mapped and superimposed residues for ITK and AurB
        ITK_CA_list, AurB_CA_list = self.sequence_align_structures(
            struct_ITK, struct_AurB
        )

        ITK_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "ITK") & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        AurB_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "AurB")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        LCK_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "LCK") & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()

        ITK_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "ITK") & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        AurB_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "AurB")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        LCK_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "LCK") & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()

        ITK_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in ITK_active_cmpds
        ]
        AurB_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in AurB_active_cmpds
        ]
        LCK_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in LCK_active_cmpds
        ]

        ITK_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in ITK_inactive_cmpds
        ]
        AurB_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in AurB_inactive_cmpds
        ]
        LCK_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in LCK_inactive_cmpds
        ]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            tmp_df["recreated_H_bond_ITK_4l7s"] = None
            tmp_df["recreated_H_bond_AurB_4af3"] = None
            tmp_df["recreated_H_bond_LCK_1fbz"] = None
            tmp_df["min_dist_gen_to_ITK_Val419"] = None
            tmp_df["com_dist_gen_to_ITK_Val419"] = None
            tmp_df["min_dist_gen_to_AurB_Leu138"] = None
            tmp_df["2d_active_sim"] = None
            tmp_df["2d_inactive_sim"] = None

            pdb_file = row["mol_cond"]
            lig_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])

            # Check if key hinge interactions are made for ITK and AurB. If in AurB file, superimpose and check if the interactions clash/are not made with ITK
            if "4l7s" in pdb_file:
                # Check if Met438 interaction created with hinge region
                itk_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                if (
                    itk_interactions is not None
                    and "RESNR" in itk_interactions["hbond"].columns
                ):
                    tmp_df["recreated_H_bond_ITK_4l7s"] = (
                        True
                        if 438 in itk_interactions["hbond"]["RESNR"].tolist()
                        else False
                    )

                tmp_df["min_dist_gen_to_ITK_Val419"] = get_smallest_atom_dist(
                    ITK_com_val419, gen_mol[0]
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, ITK_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(gen_fp, ITK_inactive_fp_list)

            elif "4af3" in pdb_file:
                ref_pdb_file = ITK_PDB
                aurb_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                (
                    gen_lig_ITK_aligned_COM,
                    itk_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    ref_pdb_file=ref_pdb_file,
                    lig_file=lig_file,
                    ref_CA_list=ITK_CA_list,
                    sample_CA_list=AurB_CA_list,
                )

                if (
                    aurb_interactions is not None
                    and "RESNR" in aurb_interactions["hbond"].columns
                ):
                    # Check if AurB Ala157 interactions re-created with hinge and ITK Met438 re-created with hinge
                    tmp_df["recreated_H_bond_AurB_4af3"] = (
                        True
                        if 157 in aurb_interactions["hbond"]["RESNR"].tolist()
                        else False
                    )
                if (
                    itk_interactions is not None
                    and "RESNR" in itk_interactions["hbond"].columns
                ):
                    tmp_df["recreated_H_bond_ITK_4l7s"] = (
                        True
                        if 438 in itk_interactions["hbond"]["RESNR"].tolist()
                        else False
                    )
                    tmp_df["com_dist_gen_to_ITK_Val419"] = np.linalg.norm(
                        gen_lig_ITK_aligned_COM - ITK_com_val419
                    )

                tmp_df["min_dist_gen_to_AurB_Leu138"] = get_smallest_atom_dist(
                    AurB_com_leu138, gen_mol[0]
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, AurB_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, AurB_inactive_fp_list
                )

            elif "1fbz" in pdb_file:
                lck_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                if (
                    lck_interactions is not None
                    and "RESNR" in lck_interactions["hbond"].columns
                ):
                    tmp_df["recreated_H_bond_LCK_1fbz"] = (
                        True
                        if 32 in lck_interactions["hbond"]["RESNR"].tolist()
                        else False
                    )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, LCK_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(gen_fp, LCK_inactive_fp_list)

            tmp_df["2d_active_sim"] = ave_2d_active_sim
            tmp_df["2d_inactive_sim"] = ave_2d_inactive_sim
            tmp_df["2d_num_active_recreated"] = active_sim_list.count(1)
            tmp_df["2d_num_inactive_recreated"] = inactive_sim_list.count(1)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def pan_JAK_activity(self):
        """
        Assess whether important hinge hydrogen bond interactions re-created across all JAK structures, regardless of input (JAK1 Leu959, JAK2 Leu932, JAK3 Leu905, TYK2 Val981)
        Additional analysis later on clashes
        """

        target_specific_metrics = pd.DataFrame()

        JAK1_PDB = None
        JAK2_PDB = None
        JAK3_PDB = None
        TYK2_PDB = None

        chembl_cmpds = pd.read_csv(os.path.join(self.chembl_dir, "JAK_TYK2_data.csv"))

        JAK1_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK1")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        JAK2_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK2")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        JAK3_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK3")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        TYK2_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "TYK2")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()

        JAK1_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK1")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        JAK2_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK2")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        JAK3_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "JAK3")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        TYK2_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "TYK2")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()

        JAK1_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in JAK1_active_cmpds
        ]
        JAK2_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in JAK2_active_cmpds
        ]
        JAK3_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in JAK3_active_cmpds
        ]
        TYK2_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in TYK2_active_cmpds
        ]

        JAK1_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in JAK1_inactive_cmpds
        ]
        JAK2_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in JAK2_inactive_cmpds
        ]
        JAK3_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in JAK3_inactive_cmpds
        ]
        TYK2_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in TYK2_inactive_cmpds
        ]

        for file in self.prot_file:
            if "5wo4" in file:
                JAK1_PDB = file
            elif "7q7k" in file:
                JAK2_PDB = file
            elif "7q6h" in file:
                JAK3_PDB = file
            elif "3lxn" in file:
                TYK2_PDB = file

        struct_JAK1 = PDB.PDBParser().get_structure("JAK1", JAK1_PDB)
        struct_JAK2 = PDB.PDBParser().get_structure("JAK2", JAK2_PDB)
        struct_JAK3 = PDB.PDBParser().get_structure("JAK3", JAK3_PDB)
        struct_TYK2 = PDB.PDBParser().get_structure("TYK2", TYK2_PDB)

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            tmp_df["recreated_H_bond_JAK1_5wo4"] = None
            tmp_df["recreated_H_bond_JAK2_7q7k"] = None
            tmp_df["recreated_H_bond_JAK3_7q6h"] = None
            tmp_df["recreated_H_bond_TYK2_3lxn"] = None
            tmp_df["com_dist_to_JAK1_Leu959"] = None
            tmp_df["com_dist_to_JAK2_Leu932"] = None
            tmp_df["com_dist_to_JAK3_Leu905"] = None
            tmp_df["com_dist_to_TYK2_Val981"] = None

            pdb_file = row["mol_cond"]
            lig_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])
            gen_lig_COM = mol_com(gen_mol[0])

            # JAK1
            if "5wo4" in pdb_file:
                JAK1_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                gen_lig_JAK1_aligned_COM = prot_com(
                    struct_JAK1[0].get_residues(), "959"
                )

                # Get mapped and superimposed residues
                JAK1_2_CA_list, JAK2_CA_list = self.sequence_align_structures(
                    struct_JAK1, struct_JAK2
                )
                JAK1_3_CA_list, JAK3_CA_list = self.sequence_align_structures(
                    struct_JAK1, struct_JAK3
                )
                JAK1_T_CA_list, TYK2_CA_list = self.sequence_align_structures(
                    struct_JAK1, struct_TYK2
                )

                (
                    gen_lig_JAK2_aligned_COM,
                    JAK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK2_PDB,
                    ref_CA_list=JAK2_CA_list,
                    sample_CA_list=JAK1_2_CA_list,
                )
                (
                    gen_lig_JAK3_aligned_COM,
                    JAK3_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK3_PDB,
                    ref_CA_list=JAK3_CA_list,
                    sample_CA_list=JAK1_3_CA_list,
                )
                (
                    gen_lig_TYK2_aligned_COM,
                    TYK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=TYK2_PDB,
                    ref_CA_list=TYK2_CA_list,
                    sample_CA_list=JAK1_T_CA_list,
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, JAK1_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, JAK1_inactive_fp_list
                )

            # JAK2
            elif "7q7k" in pdb_file:
                JAK2_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                gen_lig_JAK2_aligned_COM = prot_com(
                    struct_JAK2[0].get_residues(), "932"
                )

                # Get mapped and superimposed residues
                JAK2_1_CA_list, JAK1_CA_list = self.sequence_align_structures(
                    struct_JAK2, struct_JAK1
                )
                JAK2_3_CA_list, JAK3_CA_list = self.sequence_align_structures(
                    struct_JAK2, struct_JAK3
                )
                JAK2_T_CA_list, TYK2_CA_list = self.sequence_align_structures(
                    struct_JAK2, struct_TYK2
                )

                (
                    gen_lig_JAK1_aligned_COM,
                    JAK1_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK1_PDB,
                    ref_CA_list=JAK1_CA_list,
                    sample_CA_list=JAK2_1_CA_list,
                )
                (
                    gen_lig_JAK3_aligned_COM,
                    JAK3_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK3_PDB,
                    ref_CA_list=JAK3_CA_list,
                    sample_CA_list=JAK2_3_CA_list,
                )
                (
                    gen_lig_TYK2_aligned_COM,
                    TYK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=TYK2_PDB,
                    ref_CA_list=TYK2_CA_list,
                    sample_CA_list=JAK2_T_CA_list,
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, JAK2_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, JAK2_inactive_fp_list
                )
            # JAK3
            elif "7q6h" in pdb_file:
                JAK3_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                gen_lig_JAK3_aligned_COM = prot_com(
                    struct_JAK3[0].get_residues(), "905"
                )

                # Get mapped and superimposed residues
                JAK3_1_CA_list, JAK1_CA_list = self.sequence_align_structures(
                    struct_JAK3, struct_JAK1
                )
                JAK3_2_CA_list, JAK2_CA_list = self.sequence_align_structures(
                    struct_JAK3, struct_JAK2
                )
                JAK3_T_CA_list, TYK2_CA_list = self.sequence_align_structures(
                    struct_JAK3, struct_TYK2
                )

                (
                    gen_lig_JAK1_aligned_COM,
                    JAK1_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK1_PDB,
                    ref_CA_list=JAK1_CA_list,
                    sample_CA_list=JAK3_1_CA_list,
                )
                (
                    gen_lig_JAK2_aligned_COM,
                    JAK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK2_PDB,
                    ref_CA_list=JAK2_CA_list,
                    sample_CA_list=JAK3_2_CA_list,
                )
                (
                    gen_lig_TYK2_aligned_COM,
                    TYK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=TYK2_PDB,
                    ref_CA_list=TYK2_CA_list,
                    sample_CA_list=JAK3_T_CA_list,
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, JAK3_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, JAK3_inactive_fp_list
                )
            # TYK2
            elif "3lxn" in pdb_file:
                TYK2_interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict
                gen_lig_TYK2_aligned_COM = prot_com(
                    struct_TYK2[0].get_residues(), "981"
                )

                # Get mapped and superimposed residues
                TYK2_1_CA_list, JAK1_CA_list = self.sequence_align_structures(
                    struct_TYK2, struct_JAK1
                )
                TYK2_2_CA_list, JAK2_CA_list = self.sequence_align_structures(
                    struct_TYK2, struct_JAK2
                )
                TYK2_3_CA_list, JAK3_CA_list = self.sequence_align_structures(
                    struct_TYK2, struct_JAK3
                )

                (
                    gen_lig_JAK1_aligned_COM,
                    JAK1_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK1_PDB,
                    ref_CA_list=JAK1_CA_list,
                    sample_CA_list=TYK2_1_CA_list,
                )
                (
                    gen_lig_JAK2_aligned_COM,
                    JAK2_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK2_PDB,
                    ref_CA_list=JAK2_CA_list,
                    sample_CA_list=TYK2_2_CA_list,
                )
                (
                    gen_lig_JAK3_aligned_COM,
                    JAK3_interactions,
                ) = self.align_and_get_com_interactions(
                    pdb_file=pdb_file,
                    lig_file=lig_file,
                    ref_pdb_file=JAK3_PDB,
                    ref_CA_list=JAK3_CA_list,
                    sample_CA_list=TYK2_3_CA_list,
                )

                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, TYK2_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, TYK2_inactive_fp_list
                )

            tmp_df["2d_active_sim"] = ave_2d_active_sim
            tmp_df["2d_inactive_sim"] = ave_2d_inactive_sim
            tmp_df["2d_num_active_recreated"] = active_sim_list.count(1)
            tmp_df["2d_num_inactive_recreated"] = inactive_sim_list.count(1)

            if (
                JAK1_interactions is not None
                and "RESNR" in JAK1_interactions["hbond"].columns
            ):
                tmp_df["recreated_H_bond_JAK1_5wo4"] = (
                    True
                    if 959 in JAK1_interactions["hbond"]["RESNR"].tolist()
                    else False
                )
                if gen_lig_COM is not None:
                    tmp_df["com_dist_to_JAK1_Leu959"] = np.linalg.norm(
                        gen_lig_COM - gen_lig_JAK1_aligned_COM[0]
                    )
            else:
                tmp_df["recreated_H_bond_JAK1_5wo4"] = None
                tmp_df["com_dist_to_JAK1_Leu959"] = None
            if (
                JAK2_interactions is not None
                and "RESNR" in JAK2_interactions["hbond"].columns
            ):
                tmp_df["recreated_H_bond_JAK2_7q7k"] = (
                    True
                    if 932 in JAK2_interactions["hbond"]["RESNR"].tolist()
                    else False
                )
                if gen_lig_COM is not None:
                    tmp_df["com_dist_to_JAK2_Leu932"] = np.linalg.norm(
                        gen_lig_COM - gen_lig_JAK2_aligned_COM[0]
                    )
            else:
                tmp_df["recreated_H_bond_JAK2_7q7k"] = None
                tmp_df["com_dist_to_JAK2_Leu932"] = None
            if (
                JAK3_interactions is not None
                and "RESNR" in JAK3_interactions["hbond"].columns
            ):
                tmp_df["recreated_H_bond_JAK3_7q6h"] = (
                    True
                    if 905 in JAK3_interactions["hbond"]["RESNR"].tolist()
                    else False
                )
                if gen_lig_COM is not None:
                    tmp_df["com_dist_to_JAK3_Leu905"] = np.linalg.norm(
                        gen_lig_COM - gen_lig_JAK3_aligned_COM[0]
                    )
            else:
                tmp_df["recreated_H_bond_JAK3_7q6h"] = None
                tmp_df["com_dist_to_JAK3_Leu905"] = None
            if (
                TYK2_interactions is not None
                and "RESNR" in TYK2_interactions["hbond"].columns
            ):
                tmp_df["recreated_H_bond_TYK2_3lxn"] = (
                    True
                    if 981 in TYK2_interactions["hbond"]["RESNR"].tolist()
                    else False
                )
                if gen_lig_COM is not None:
                    tmp_df["com_dist_to_TYK2_Val981"] = np.linalg.norm(
                        gen_lig_COM - gen_lig_TYK2_aligned_COM[0]
                    )
            else:
                tmp_df["recreated_H_bond_TYK2_3lxn"] = None
                tmp_df["com_dist_to_TYK2_Val981"] = None

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def pan_BET_activity(self):
        """
        Assess whether important interactions re-created across all BET structures, regardless of input
        And whether generated compounds are similar to those in literature
        """

        target_specific_metrics = pd.DataFrame()

        (
            struct_6ddi,
            struct_5ig6,
            struct_7lay,
            struct_3s92,
            struct_4bq3,
            struct_7usg,
            struct_7mrd,
            struct_7l99,
        ) = [None] * 8

        # Get mapped and superimposed residues for all bromodomain structures to 6DDI
        for file in self.prot_file:
            if "6ddi" in file:
                file_6ddi = file
                struct_6ddi = PDB.PDBParser().get_structure("6ddi", file_6ddi)
            elif "5ig6" in file:
                file_5ig6 = file
                struct_5ig6 = PDB.PDBParser().get_structure("5ig6", file_5ig6)
            elif "7lay" in file:
                file_7lay = file
                struct_7lay = PDB.PDBParser().get_structure("7lay", file_7lay)
            elif "3s92" in file:
                file_3s92 = file
                struct_3s92 = PDB.PDBParser().get_structure("3s92", file_3s92)
            elif "4bq3" in file:
                file_4bq3 = file
                struct_4bq3 = PDB.PDBParser().get_structure("4bq3", file_4bq3)
            elif "7usg" in file:
                file_7usg = file
                struct_7usg = PDB.PDBParser().get_structure("7usg", file_7usg)
            elif "7mrd" in file:
                file_7mrd = file
                struct_7mrd = PDB.PDBParser().get_structure("7mrd", file_7mrd)
            elif "7l99" in file:
                file_7l99 = file
                struct_7l99 = PDB.PDBParser().get_structure("7l99", file_7l99)

        # Get mapped and superimposed residues for to 6DDI
        CA_list_6ddi_BD22, CA_list_5ig6 = self.sequence_align_structures(
            struct_6ddi, struct_5ig6
        )
        CA_list_6ddi_BD31, CA_list_7lay = self.sequence_align_structures(
            struct_6ddi, struct_7lay
        )
        CA_list_6ddi_BD32, CA_list_3s92 = self.sequence_align_structures(
            struct_6ddi, struct_3s92
        )
        CA_list_6ddi_BD41, CA_list_4bq3 = self.sequence_align_structures(
            struct_6ddi, struct_4bq3
        )
        CA_list_6ddi_BD42, CA_list_7usg = self.sequence_align_structures(
            struct_6ddi, struct_7usg
        )
        CA_list_6ddi_BDT1, CA_list_7mrd = self.sequence_align_structures(
            struct_6ddi, struct_7mrd
        )
        CA_list_6ddi_BDT2, CA_list_7l99 = self.sequence_align_structures(
            struct_6ddi, struct_7l99
        )

        chembl_cmpds = pd.read_csv(
            os.path.join(self.chembl_dir, "BET_literature_and_ChEMBL_cmpds_joined.csv")
        )

        BRD2_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD2")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        BRD3_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD3")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        BRD4_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD4")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()
        BRDT_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRDT")
            & (chembl_cmpds["pchembl_value_mean"] > 7)
        ]["canonical_smiles"].tolist()

        BRD2_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD2")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        BRD3_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD3")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        BRD4_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRD4")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()
        BRDT_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "BRDT")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()

        BRD2_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in BRD2_active_cmpds
        ]
        BRD3_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in BRD3_active_cmpds
        ]
        BRD4_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in BRD4_active_cmpds
        ]
        BRDT_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in BRDT_active_cmpds
        ]

        BRD2_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in BRD2_inactive_cmpds
        ]
        BRD3_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in BRD3_inactive_cmpds
        ]
        BRD4_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in BRD4_inactive_cmpds
        ]
        BRDT_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in BRDT_inactive_cmpds
        ]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            pdb_file = row["mol_cond"]
            lig_file = row["mol_pred"]
            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None][0]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict

            # Check if conserved interactions are re-created - minimum
            # Additional interactions from 6DDI - required for potent compounds
            # Coordinates of WPF motif which the cyanophenol CN nitrogen interacts with in 6DDI
            WPF_coords = [18.89, 19.11, -12.46]
            # Coordinates of ZA channel which pyrazole end N interacts with in 6DDI
            ZA_channel_coords = [14.5, 12.43, -12.88]

            combined_struct = None
            WPF_dist = None
            ZA_dist = None

            # BRD2 BD1 6DDI - Asn156 and Tyr113 (water bound)
            if "6ddi" in pdb_file:
                asn_res = 156
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD2_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD2_inactive_fp_list
                )
                WPF_dist = get_smallest_atom_dist(WPF_coords, gen_mol)
                ZA_dist = get_smallest_atom_dist(ZA_channel_coords, gen_mol)
            # BRD2 BD2 5IG6 - Asn429 and Tyr386 (water bound)
            elif "5ig6" in pdb_file:
                asn_res = 429
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD2_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD2_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BD22, CA_list_5ig6
                )
            # BRD3 BD1 7LAY - Asn116 and Tyr73 (water bound)
            elif "7lay" in pdb_file:
                asn_res = 116
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD3_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD3_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BD31, CA_list_7lay
                )
            # BRD3 BD2 3S92 - Asn391 and Tyr348 (water bound)
            elif "3s92" in pdb_file:
                asn_res = 391
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD3_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD3_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BD32, CA_list_3s92
                )
            # BRD4 BD1 4BQ3 - Asn140 and Tyr97 (water bound)
            elif "4bq3" in pdb_file:
                asn_res = 140
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD4_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD4_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BD41, CA_list_4bq3
                )
            # BRD4 BD2 7USG - Asn429 and Tyr386 (water bound)
            elif "7usg" in pdb_file:
                asn_res = 429
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRD4_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRD4_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BD42, CA_list_7usg
                )
            # BRDT BD1 7MRD - Asn109 and Tyr66 (water bound)
            elif "7mrd" in pdb_file:
                asn_res = 109
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRDT_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRDT_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BDT1, CA_list_7mrd
                )
            # BRDT BD2 7L99 - Asn351 and Tyr308 (water bound)
            elif "7l99" in pdb_file:
                asn_res = 351
                # 2D similarity between ChEMBL and generated compound
                active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, BRDT_active_fp_list)
                inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(
                    gen_fp, BRDT_inactive_fp_list
                )

                combined_struct = self.align_structures(
                    pdb_file, lig_file, CA_list_6ddi_BDT2, CA_list_7l99
                )

            if interactions is not None and "RESNR" in interactions["hbond"].columns:
                tmp_df["recreated_Asn_bond"] = (
                    True
                    if asn_res in interactions["hbond"]["RESNR"].tolist()
                    else False
                )
            else:
                tmp_df["recreated_Asn_bond"] = None

            tmp_df["2d_active_sim"] = ave_2d_active_sim
            tmp_df["2d_inactive_sim"] = ave_2d_inactive_sim
            tmp_df["2d_num_active_recreated"] = active_sim_list.count(1)
            tmp_df["2d_num_inactive_recreated"] = inactive_sim_list.count(1)

            if combined_struct is not None:
                # Save lig file to get interactions
                io = PDB.PDBIO()
                io.set_structure(combined_struct[0]["Z"])
                io.save("tmp_lig_aligned.pdb")
                gen_mol_aligned = Chem.MolFromPDBFile(
                    "tmp_lig_aligned.pdb", removeHs=False
                )

                WPF_dist = get_smallest_atom_dist(WPF_coords, gen_mol_aligned)
                ZA_dist = get_smallest_atom_dist(ZA_channel_coords, gen_mol_aligned)

            tmp_df["min_WPF_dist"] = WPF_dist
            tmp_df["min_ZA_dist"] = ZA_dist

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def shik_activity(self):
        """
        Assess whether important interactions re-created (Asp34 and Arg58)
        """

        target_specific_metrics = pd.DataFrame()

        chembl_cmpds = pd.read_csv(os.path.join(self.chembl_dir, "shik_data.csv"))

        shik_med_active_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "Shik kinase")
            & (chembl_cmpds["pchembl_value_mean"] >= 6)
        ]["canonical_smiles"].tolist()
        shik_inactive_cmpds = chembl_cmpds[
            (chembl_cmpds["target"] == "Shik kinase")
            & (chembl_cmpds["pchembl_value_mean"] < 5)
        ]["canonical_smiles"].tolist()

        shik_med_active_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in shik_med_active_cmpds
        ]
        shik_inactive_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1])
            for cmpd in shik_inactive_cmpds
        ]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            pdb_file = row["mol_cond"]
            lig_file = row["mol_pred"]

            interactions = recreatedPLIP(pdb_file, lig_file).interaction_dict

            if interactions is not None and "RESNR" in interactions["hbond"].columns:
                tmp_df["recreated_H_bond_Asp34"] = (
                    True if 34 in interactions["hbond"]["RESNR"].tolist() else False
                )
            else:
                tmp_df["recreated_H_bond_Asp34"] = None
            if (
                interactions is not None
                and "RESNR" in interactions["saltbridge"].columns
            ):
                tmp_df["recreated_Arg58"] = (
                    True
                    if 58 in interactions["saltbridge"]["RESNR"].tolist()
                    else False
                )
            else:
                tmp_df = None

            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None]
            gen_fp = Chem.RDKFingerprint(gen_mol[0])

            # 2D similarity between ChEMBL and generated compound
            active_sim_list, ave_2d_active_sim = ave_sim_2d_to_chembl(gen_fp, shik_med_active_fp_list)
            inactive_sim_list, ave_2d_inactive_sim = ave_sim_2d_to_chembl(gen_fp, shik_inactive_fp_list)

            tmp_df["2d_active_sim"] = ave_2d_active_sim
            tmp_df["2d_inactive_sim"] = ave_2d_inactive_sim
            tmp_df["2d_num_active_recreated"] = active_sim_list.count(1)
            tmp_df["2d_num_inactive_recreated"] = inactive_sim_list.count(1)

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics


class task3Metrics:
    def __init__(
        self,
        output_df_for_prot,
        chembl_csv_dir="Benchmarking_Tasks/Task3",
    ):
        """
        Task 3 specific metrics for unseen targets with specific requirements

        Parameters
        ----------
            output_df_for_prot: pandas DataFrame
                Output DataFrame from with per compound scores from class metricCalcs, filtered for one protein
            chembl_csv_dir: str
                Directory containing Task3 csv files containing compounds from ChEMBL
        """

        # Only use samples that have SDF files that exist
        self.output_df_for_prot = output_df_for_prot[
            ~output_df_for_prot["mol_pred"].astype(str).str.contains("Errno")
        ]
        self.prot_file = list(self.output_df_for_prot["mol_cond"].unique())

        self.chembl_dir = chembl_csv_dir

    def COVID_moonshot(self):
        """
        Analysis of COVID-19 Moonshot hit data
        """

        target_specific_metrics = pd.DataFrame()

        # 2D similarity with hits
        hits = pd.read_csv(
            os.path.join(
                self.chembl_dir,
                "COVID_Moonshot/confirmed_hits_SMILES_structure_tagged.csv",
            )
        )
        hits_smi = hits["SMILES_clean"].unique()

        true_crystal_lig_mol = [
            mol
            for mol in Chem.SDMolSupplier(
                list(self.output_df_for_prot["mol_true"].unique())[0]
            )
            if mol != None
        ][0]
        chembl_moonshot_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in hits_smi
        ]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            pdb_file = row["mol_cond"]
            lig_file = row["mol_pred"]

            # Average 2D similarity
            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None][0]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            # 2D similarity between ChEMBL and generated compound
            active_sim_2d, hit_sim_2d = ave_sim_2d_to_chembl(gen_fp, chembl_moonshot_fp_list)

            # 3D similarity with ligand in 7gax
            true_sim_3d = sim_3d(gen_mol, true_crystal_lig_mol)

            tmp_df["2d_hits_ave_sim"] = hit_sim_2d
            tmp_df["2d_hits_num_recreated"] = active_sim_2d.count(1)
            tmp_df["3d_crystal_sim"] = true_sim_3d

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

    def CSAR_2014(self):
        """
        Analysis of CSAR2014 hit data
        """

        target_specific_metrics = pd.DataFrame()

        # 2D similarity with hits
        fXa_hits = pd.read_csv(os.path.join(self.chembl_dir, "CSAR2014/fXa_cmpds.csv"))
        fXa_hits_smi = fXa_hits["smiles"].unique()
        syk_hits = pd.read_csv(os.path.join(self.chembl_dir, "CSAR2014/syk_cmpds.csv"))
        syk_hits_smi = syk_hits["smiles"].unique()
        trmd_hits = pd.read_csv(
            os.path.join(self.chembl_dir, "CSAR2014/trmd_cmpds.csv")
        )
        trmd_hits_smi = trmd_hits["smiles"].unique()

        chembl_csar2014_fXa_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in fXa_hits_smi
        ]
        chembl_csar2014_syk_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in syk_hits_smi
        ]
        chembl_csar2014_trmd_fp_list = [
            Chem.RDKFingerprint(standardize_cmpd(cmpd)[1]) for cmpd in trmd_hits_smi
        ]

        for idx, row in self.output_df_for_prot.iterrows():
            tmp_df = pd.DataFrame([row])

            lig_file = row["mol_pred"]
            crystal_lig_file = row["mol_true"]

            crystal_mol = [
                mol for mol in Chem.SDMolSupplier(crystal_lig_file) if mol != None
            ][0]

            # Average 2D similarity
            gen_mol = [mol for mol in Chem.SDMolSupplier(lig_file) if mol != None][0]
            gen_fp = Chem.RDKFingerprint(gen_mol)

            # 3D similarity with crystal ligand
            true_sim_3d = sim_3d(gen_mol, crystal_mol)

            lig_file_basename = os.path.basename(crystal_lig_file)
            lig_file_pdb_id = lig_file_basename.split("_")[0]

            # Check if fXa
            if lig_file_pdb_id in [
                "4ZH8",
                "4Y6D",
                "4ZHA",
                "4Y71",
                "4Y76",
                "4Y79",
                "4Y7A",
                "4Y7B",
            ]:
                csar2014_fp_list = chembl_csar2014_fXa_fp_list
            # Check if SYK
            elif lig_file_pdb_id in [
                "4YJO",
                "4YJP",
                "4YJQ",
                "4YJR",
                "4YJS",
                "4YJT",
                "4YJU",
                "4YJV",
            ]:
                csar2014_fp_list = chembl_csar2014_syk_fp_list
            # Otherwise TRMD
            else:
                csar2014_fp_list = chembl_csar2014_trmd_fp_list

            # 2D similarity between ChEMBL and generated compound
            active_sim_2d, hit_sim_2d = ave_sim_2d_to_chembl(gen_fp, csar2014_fp_list)

            tmp_df["2d_hits_ave_sim"] = hit_sim_2d
            tmp_df["2d_hits_num_recreated"] = active_sim_2d.count(1)
            tmp_df["3d_crystal_sim"] = true_sim_3d

            target_specific_metrics = pd.concat([target_specific_metrics, tmp_df])

        return target_specific_metrics

class task4Metrics:
    def __init__(self, task1_df, task2_df, task3_df, n_samples=50):
        """
        Parameters
        ----------
            task1_df, task1_df, task1_df: Pandas DataFrames
                Pandas DataFrame containing outputs for each task
            n_samples: integer
                Number of samples to get per task output
        """
        
        task1_df["Task"] = 1
        task2_df["Task"] = 2
        task3_df["Task"] = 3
        
        task1_df = task1_df[
            ~task1_df["mol_pred"].astype(str).str.contains("Errno")
        ]
        task2_df = task2_df[
            ~task2_df["mol_pred"].astype(str).str.contains("Errno")
        ]
        task3_df = task3_df[
            ~task3_df["mol_pred"].astype(str).str.contains("Errno")
        ]
        
        task1_df = self.sample_df_per_prot_group(task1_df, n_samples=n_samples)
        task2_df = self.sample_df_per_prot_group(task2_df, n_samples=n_samples)
        task3_df = self.sample_df_per_prot_group(task3_df, n_samples=n_samples)
        
        self.task_df = pd.concat([task1_df, task2_df])
        self.task_df = pd.concat([self.task_df, task3_df])

        self.dpocket_pdbs = DPOCKET_TYPES["PDB ID"].unique()
        self.dpocket_types = DPOCKET_TYPES

        # Write a dictionary for each distribution metric of the form
        # {protein_test: {ligand_type: [], pocket_type: []}
        self.task4_dict = {}

        # Patterns for Bemis-Murcko scaffold conversion from RDKit
        self.pattern = Chem.MolFromSmarts("[$([D1]=[*])]")
        self.replace = Chem.MolFromSmarts("[*]")

        self.task1_proteins = list(BLIND_SET_PDBS_TO_POCKET_IDS.keys())
        self.task2_proteins = []
        for key, val in TASK2_FUNC_TO_PDBS.items():
            self.task2_proteins.extend([i.strip().strip("'") for i in val.split(",")])
        self.task3_proteins = set(ALL_PDBS) - (
            set(self.task1_proteins).union(set(self.task2_proteins))
        )
        
    def sample_df_per_prot_group(self, df, n_samples):
        df_sampled = pd.DataFrame()
        
        df_grouped = df[['PDB ID', 'mol_pred']].groupby('PDB ID').count().reset_index()
        
        # For each PDB group, check if enough samples, otherwise get max possible
        for pdb in df_grouped["PDB ID"].tolist():
            pdb_df = df[df["PDB ID"] == pdb]
            
            if len(pdb_df) < n_samples:
                df_sample = pdb_df
            else:
                df_sample = pdb_df.sample(n=n_samples, random_state=42)
                
            df_sampled = pd.concat([df_sampled, df_sample])
            
        return df_sampled

    def ligand_type(self, task_df):
        """
        Gets ring information and similarity of ligands calculated from previous tasks

        Parameters
        ----------
            task_df: pandas DataFrame
                Task-specific metrics

        Returns
        -------
            tuple of frameworks, rings, and similarities
        """
        
        smiles = []

        atomic_frameworks = []
        graph_frameworks = []
        num_rings = []
        ring_info_list = []
        
        maximum_ring_size = []
        minimum_ring_size = []

        # Get generated molecules
        for i in task_df["mol_pred"]:
            try:
                mol = [m for m in Chem.SDMolSupplier(i)][0]
            except:
                mol = None

            if mol is not None:
                smiles.append(Chem.MolToSmiles(mol))

    def run(self):
        """
        Runs task4 metrics for each task specific output file from tasks 1, 2, and 3

        Returns
        -------
            Dictionaries of final task 4 analysis and apo/holo structure analysis
        """
        
        prot_ids = self.task_df["PDB ID"].unique()

        # Distributions
        for prot in prot_ids:
            task_df = self.task_df[self.task_df["PDB ID"] == prot]
            task_cols = list(task_df.columns)
            
            # Get test name
            if task_df["Task"].iloc[0] == 1:
                protein_id_name = BLIND_SET_PDBS_TO_POCKET_IDS[prot]
            elif task_df["Task"].iloc[0] == 2:
                if prot in TASK2_FUNC_TO_PDBS["ITK_selectivity"]:
                    protein_id_name = "ITK_selectivity"
                elif prot in TASK2_FUNC_TO_PDBS['pan_JAK_activity']:
                    protein_id_name = 'pan_JAK_activity'
                elif prot in TASK2_FUNC_TO_PDBS['pan_BET_activity']:
                    protein_id_name = 'pan_BET_activity'
                elif prot in TASK2_FUNC_TO_PDBS['shik_activity']:
                    protein_id_name = 'shik_activity'
            elif task_df["Task"].iloc[0] == 3:
                if prot == '7gax':
                    protein_id_name = 'COVID_moonshot'
                else:
                    protein_id_name = 'CSAR_2014'

            # If the PDB is already part of DPocket, get the volume back, otherwise find the same protein but different PDB for task 1
            if prot not in self.dpocket_pdbs:
                # Get similar/same protein just different PDB
                if prot in self.task1_proteins:
                    # Get protein ID
                    prot_id = BLIND_SET_PDBS_TO_POCKET_IDS[prot]

                    # Get other PDBs part of the same protein
                    other_pdbs = BLIND_SET_POCKET_IDS[prot_id]
                    other_pdbs = [
                        i.strip().strip("'") for i in other_pdbs.split(",")
                    ]
                    pdbs_not_curr = [
                        i for i in other_pdbs if i != prot
                    ]  # Get a PDB which isn't the current protein we are studying

                    new_prot = None
                    for pdb in pdbs_not_curr:
                        if pdb in self.dpocket_pdbs:
                            new_prot = prot
                else:
                    continue  # Ignore for 1zyu
            else:
                new_prot = prot

            if new_prot in self.dpocket_pdbs:
                dpocket_info = self.dpocket_types[
                    self.dpocket_types["PDB ID"] == new_prot
                ]
                pocket_vol = list(dpocket_info["pock_vol"])[0]
                lig_vol = list(dpocket_info["lig_vol"])[0]
                mean_SASA = list(dpocket_info["mean_as_solv_acc"])[0]
                hydrophobicity = list(dpocket_info["hydrophobicity_score"])[0]

                self.task4_dict[protein_id_name][prot]["pocket_type"][
                    "pocket_volume"
                ] = pocket_vol
                self.task4_dict[protein_id_name][prot]["pocket_type"][
                    "ligand_volume"
                ] = lig_vol
                self.task4_dict[protein_id_name][prot]["pocket_type"][
                    "mean_as_solv_acc"
                ] = mean_SASA
                self.task4_dict[protein_id_name][prot]["pocket_type"][
                    "hydrophobicity_score"
                ] = hydrophobicity
            

        return self.task4_dict
        
